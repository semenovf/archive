/* AUTOMATICALLY GENERATED BY 'binder_gen.pl' */
/*
 * binder.hpp
 *
 *  Created on: 2016-09-22 16:24:14
 *      Author: wladt
 */

#ifndef __PFS_BINDER_HPP__
#define __PFS_BINDER_HPP__

#include <pfs/debug.hpp>

namespace pfs {

template <typename T>
struct binder_type_trait { typedef T type; };

template <typename T>
struct binder_type_trait<const T &> { typedef T type; };

template <typename Return>
class binder_base
{
public:
    typedef Return return_type;

protected:
    size_t _size;
    size_t _magic; // TODO Remove

    binder_base (size_t size)
        : _size(size)
        , _magic(0xDEADBEAF) // TODO Remove
    {}

public:
    virtual ~binder_base () 
    {
        _magic = 0xDEADDEAD; // TODO Remove
    }

    size_t size () const
    {
        return _size;
    }

    virtual return_type operator () () const = 0;
    
    virtual void * placement_copy (void * ptr) const = 0;
    
    void * pcopy (void * ptr)
    {
        return placement_copy(ptr);
    }
    
    size_t magic () const
    {
        return _magic;
    }
};


template <typename Return>
class binder_function_base : public binder_base<Return>
{
public:
    typedef Return return_type;
    typedef return_type (* funcptr_type) ();

protected:
    funcptr_type _f;

    binder_function_base (size_t size, funcptr_type f)
        : binder_base<Return>(size)
        , _f(f)
    {}

public:
    virtual ~binder_function_base () {}

//    virtual return_type operator () () const = 0;
};

template <typename Class, typename Return>
class binder_method_base : public binder_base<Return>
{
public:
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) ();

protected:
    Class * _p;
    funcptr_type _f;

    binder_method_base (size_t size, Class * p, funcptr_type f)
        : binder_base<Return>(size)
        , _p(p)
        , _f(f)
    { }

public:
    virtual ~binder_method_base () {}

//    virtual return_type operator () () const = 0;
};


template <typename Return>
class binder_function0 : public binder_function_base<Return>
{

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) ();

    binder_function0 (funcptr_type f)
        : base_class(sizeof(binder_function0)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
    {}

    virtual ~binder_function0 () 
    {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f();
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function0(*this)) + 1;
    }
};

template <typename Return, typename Arg1>
class binder_function1 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1);

    binder_function1 (funcptr_type f, Arg1 a1)
        : base_class(sizeof(binder_function1)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
    {}

    virtual ~binder_function1 () 
    {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function1(*this)) + 1;
    }
};

template <typename Return, typename Arg1, typename Arg2>
class binder_function2 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1, Arg2);

    binder_function2 (funcptr_type f, Arg1 a1, Arg2 a2)
        : base_class(sizeof(binder_function2)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
    {}

    virtual ~binder_function2 () 
    {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1, _a2);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function2(*this)) + 1;
    }
};

template <typename Return, typename Arg1, typename Arg2, typename Arg3>
class binder_function3 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1, Arg2, Arg3);

    binder_function3 (funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3)
        : base_class(sizeof(binder_function3)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
    {}

    virtual ~binder_function3 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1, _a2, _a3);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function3(*this)) + 1;
    }
};

template <typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class binder_function4 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1, Arg2, Arg3, Arg4);

    binder_function4 (funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4)
        : base_class(sizeof(binder_function4)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
    {}

    virtual ~binder_function4 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1, _a2, _a3, _a4);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function4(*this)) + 1;
    }
};

template <typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
class binder_function5 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5);

    binder_function5 (funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5)
        : base_class(sizeof(binder_function5)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
    {}

    virtual ~binder_function5 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1, _a2, _a3, _a4, _a5);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function5(*this)) + 1;
    }
};

template <typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
class binder_function6 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;
    typename binder_type_trait<Arg6>::type _a6;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);

    binder_function6 (funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6)
        : base_class(sizeof(binder_function6)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
        , _a6(a6)
    {}

    virtual ~binder_function6 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1, _a2, _a3, _a4, _a5, _a6);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function6(*this)) + 1;
    }
};

template <typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
class binder_function7 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;
    typename binder_type_trait<Arg6>::type _a6;
    typename binder_type_trait<Arg7>::type _a7;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);

    binder_function7 (funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6, Arg7 a7)
        : base_class(sizeof(binder_function7)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
        , _a6(a6)
        , _a7(a7)
    {}

    virtual ~binder_function7 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1, _a2, _a3, _a4, _a5, _a6, _a7);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function7(*this)) + 1;
    }

};

template <typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
class binder_function8 : public binder_function_base<Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;
    typename binder_type_trait<Arg6>::type _a6;
    typename binder_type_trait<Arg7>::type _a7;
    typename binder_type_trait<Arg8>::type _a8;

public:
    typedef binder_function_base<Return> base_class;
    typedef Return return_type;
    typedef return_type (* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);

    binder_function8 (funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6, Arg7 a7, Arg8 a8)
        : base_class(sizeof(binder_function8)
                , reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
        , _a6(a6)
        , _a7(a7)
        , _a8(a8)
    {}

    virtual ~binder_function8 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return f(_a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_function8(*this)) + 1;
    }
};

template <typename Class, typename Return>
class binder_method0 : public binder_method_base<Class, Return>
{
public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) ();

    binder_method0 (Class * p, funcptr_type f)
        : base_class(sizeof(binder_method0)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
    {}

    virtual ~binder_method0 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)();
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method0(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1>
class binder_method1 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1);

    binder_method1 (Class * p, funcptr_type f, Arg1 a1)
        : base_class(sizeof(binder_method1)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
    {}

    virtual ~binder_method1 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method1(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1, typename Arg2>
class binder_method2 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1, Arg2);

    binder_method2 (Class * p, funcptr_type f, Arg1 a1, Arg2 a2)
        : base_class(sizeof(binder_method2)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
    {}

    virtual ~binder_method2 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1, _a2);
    }

    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method2(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1, typename Arg2, typename Arg3>
class binder_method3 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1, Arg2, Arg3);

    binder_method3 (Class * p, funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3)
        : base_class(sizeof(binder_method3)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
    {}

    virtual ~binder_method3 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1, _a2, _a3);
    }

    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method3(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class binder_method4 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1, Arg2, Arg3, Arg4);

    binder_method4 (Class * p, funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4)
        : base_class(sizeof(binder_method4)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
    {}

    virtual ~binder_method4 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1, _a2, _a3, _a4);
    }

    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method4(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
class binder_method5 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5);

    binder_method5 (Class * p, funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5)
        : base_class(sizeof(binder_method5)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
    {}

    virtual ~binder_method5 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1, _a2, _a3, _a4, _a5);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method5(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
class binder_method6 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;
    typename binder_type_trait<Arg6>::type _a6;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);

    binder_method6 (Class * p, funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6)
        : base_class(sizeof(binder_method6)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
        , _a6(a6)
    {}

    virtual ~binder_method6 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1, _a2, _a3, _a4, _a5, _a6);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method6(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7>
class binder_method7 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;
    typename binder_type_trait<Arg6>::type _a6;
    typename binder_type_trait<Arg7>::type _a7;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);

    binder_method7 (Class * p, funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6, Arg7 a7)
        : base_class(sizeof(binder_method7)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
        , _a6(a6)
        , _a7(a7)
    {}

    virtual ~binder_method7 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1, _a2, _a3, _a4, _a5, _a6, _a7);
    }
    
    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method7(*this)) + 1;
    }
};

template <typename Class, typename Return, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8>
class binder_method8 : public binder_method_base<Class, Return>
{
    typename binder_type_trait<Arg1>::type _a1;
    typename binder_type_trait<Arg2>::type _a2;
    typename binder_type_trait<Arg3>::type _a3;
    typename binder_type_trait<Arg4>::type _a4;
    typename binder_type_trait<Arg5>::type _a5;
    typename binder_type_trait<Arg6>::type _a6;
    typename binder_type_trait<Arg7>::type _a7;
    typename binder_type_trait<Arg8>::type _a8;

public:
    typedef binder_method_base<Class, Return> base_class;
    typedef Return return_type;
    typedef return_type (Class::* funcptr_type) (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);

    binder_method8 (Class * p, funcptr_type f, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6, Arg7 a7, Arg8 a8)
        : base_class(sizeof(binder_method8)
                , p, reinterpret_cast<typename base_class::funcptr_type>(f))
        , _a1(a1)
        , _a2(a2)
        , _a3(a3)
        , _a4(a4)
        , _a5(a5)
        , _a6(a6)
        , _a7(a7)
        , _a8(a8)
    {}

    virtual ~binder_method8 () {}

    virtual return_type operator () () const
    {
        funcptr_type f = reinterpret_cast<funcptr_type>(this->_f);
        return (base_class::_p->*f)(_a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8);
    }

    void * placement_copy (void * ptr) const
    {
        return (new (ptr) binder_method8(*this)) + 1;
    }
};

} // pfs

#endif /* __PFS_BINDER_HPP__ */

