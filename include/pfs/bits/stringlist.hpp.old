/**
 * @file stringlist.hpp
 * @author wladt
 * @date Apr 3, 2014
 */

#ifndef __PFS_BITS_STRINGLIST_HPP__
#define __PFS_BITS_STRINGLIST_HPP__

#include <pfs/vector.hpp>

namespace pfs {

template <typename StringT>
class stringlist_basic : public pfs::vector<StringT>
{
	typedef pfs::vector<StringT> base_class;
	typedef stringlist_basic<StringT> self_class;

public:
	typedef typename base_class::value_type      value_type;
	typedef typename base_class::pointer         pointer;
	typedef typename base_class::const_pointer   const_pointer;
	typedef typename base_class::size_type       size_type;
	typedef typename base_class::difference_type difference_type;

	typedef pfs::reference<self_class>                  reference;
	typedef pfs::reference<const self_class>            const_reference;
	typedef pfs::random_access_iterator<self_class>     iterator;
	typedef pfs::random_access_iterator<const self_class> const_iterator;
    typedef std::reverse_iterator<iterator>		        reverse_iterator;
    typedef std::reverse_iterator<const_iterator>       const_reverse_iterator;

    typedef value_type char_type; // used in FSM e.g.

	stringlist_basic () : base_class() {}
//	stringlist_basic (const string_type & str) : base_class() { append(str); }
	stringlist_basic (const stringlist_basic & other) : base_class(other) {}

//	stringlist_basic operator + (const stringlist_basic & other) const
//	{
//		stringlist_basic r(*this);
//		r.append(other);
//		return r;
//	}

	stringlist_basic & operator << (const StringT & s)              { this->append(s); return *this; }
	stringlist_basic & operator << (const char * latin1)            { this->append(StringT::fromLatin1(latin1)); return *this; }
	stringlist_basic & operator << (const stringlist_basic & other) { this->append(other); return *this; }
};

} // pfs

#endif // __PFS_BITS_STRINGLIST_HPP__
