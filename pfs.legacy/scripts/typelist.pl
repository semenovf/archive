#!/bin/perl -w

#
# Return string in format:
# template <typename T1, typename T2, ..., typename T<$count>>
#
sub template_decl_str
{
    my $count = shift or die;	
    my $r = 'template <typename T1';
    
    for (my $i = 2; $i <= $count; ++$i) {
       $r .= ', typename T' . $i;
    }
    
    $r .= '>';
    return $r;
}

#
# Return string in format
#
#struct cons<T1
#    , T2
#    , null_typelist
#    , null_typelist>
#
sub spec_class_decl_str
{
    my $specStructCounter = shift or die;
    my $numberOfSpecStructs = shift or die;
    my $r = 'struct cons <T1';
    
    for (my $i = 2; $i <= $specStructCounter; ++$i) {
       $r .= "\n\t, T" . $i;
    }
    
    for (my $i = $specStructCounter; $i <= $numberOfSpecStructs; ++$i) {
    	$r .= "\n\t, null_typelist";
    } 
    
    $r .= '>';
    return $r;
}

# Return string in format:
#
#    typedef typelist<T1
#            , typelist<T2
#            , typelist<T3, null_typelist>
#    > > type;
sub spec_class_body_str
{
    my $specStructCounter = shift or die;
    
    my $r = "\ttypedef typelist<T1";

    for (my $i = 2; $i <= $specStructCounter; ++$i) {
       $r .= "\n\t\t, typelist<T" . $i;
    }

    $r .= ', null_typelist>';
    $r .= "\n\t";

    for (my $i = 2; $i <= $specStructCounter; ++$i) {
        $r .= '> ';
    }

    $r .= 'type;';
    return $r;
}

my ($sec
    , $min
    , $hour
    , $mday
    , $mon
    , $year
    , $wday
    , $yday
    , $isdst) = localtime(time);
my $now = sprintf("%04d-%02d-%02d %02d:%02d:%02d"
    , $year + 1900
    , $mon + 1
    , $mday, $hour, $min, $sec);

my $thisScriptName = $0;
my $numberOfParms = 0 + $ARGV[0];

if ($numberOfParms == 0) {
    $numberOfParms = 4;
}

print <<"END_OF_TEXT";
/*
 * typelist.hpp
 * AUTOMATICALLY GENERATED BY '${thisScriptName}'
 *
 *  Created on: ${now}
 *      Author: wladt
 *  
 */

#ifndef __PFS_BITS_TYPELIST_HPP__
#define __PFS_BITS_TYPELIST_HPP__

//
// see http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2002/cexp2002/alexandr/alexandr.htm
//

//#if __cplusplus >= 201103L // C++11
//# error You are using C++11 compliant compiler.
//# error Use variadic templates to implement 'cons' struct.
//#endif

namespace pfs {

template <typename Head, typename Tail>
struct typelist
{
\ttypedef Head head;
\ttypedef Tail tail;
};

struct null_typelist {};

END_OF_TEXT

#
# Print main struct
#
print 'template <class T1';
for (my $i = 2; $i <= $numberOfParms; ++$i) {
	print "\n\t, typename T" . $i;
}

print ">\nstruct cons\n{";

# EXAMPLE {
#    typedef typelist<T1
#            , typelist<T2
#            , typelist<T3
#            , typelist<T4, null_typelist>
#    > > > type;
print "\ttypedef typelist<T1";

for (my $i = 2; $i <= $numberOfParms; ++$i) {
    print "\n\t\t, typelist<T" . $i;
}
print ', null_typelist>';
print "\n\t";

for (my $i = 2; $i <= $numberOfParms; ++$i) {
	print '> ';
}
print 'type;';

# } EXAMPLE 

print "\n};\n";

#
# Print specialized structs
#
my $specStructCounter = 1;
my $numberOfSpecStructs = $numberOfParms - 1;

for (my $i = 0; $i < $numberOfSpecStructs; ++$i) {
    print "\n", template_decl_str($specStructCounter);
    print "\n", spec_class_decl_str($specStructCounter, $numberOfSpecStructs);
    print "\n{\n";
    print spec_class_body_str($specStructCounter);
    print "\n};\n";
    
    ++$specStructCounter;
}


print <<"END_OF_TEXT";

template <class TypeList> struct typelist_max_size;

template <>
struct typelist_max_size<null_typelist>
{
    enum { result = 0 };
};

template <typename Head, typename Tail>
struct typelist_max_size<typelist<Head, Tail> >
{
private:
    enum { tailResult = size_t(typelist_max_size<Tail>::result) };
public:
    enum { result = sizeof(Head) > tailResult
        ? sizeof(Head)
        : size_t(tailResult)
    };
};

} // pfs

#endif /* __PFS_BITS_TYPELIST_HPP__ */
END_OF_TEXT

0;